<head>
  <style> body { margin: 0; } </style>
  <script src="libraries/3d-force-graph.js"></script>
  <script src="libraries/index.min.js"></script>
  <script src="libraries/three.js"></script>
  <script src="libraries/three-spritetext.min.js"></script>
  <script src="libraries/dat.gui.js"></script>
  <script src="libraries/d3.v3.min.js" charset="utf-8"></script>
  <script src="libraries/rainbowvis.js"></script>
  <script src="https://github.com/mrdoob/three.js/blob/dev/examples/jsm/deprecated/Geometry.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tweakpane@3.0.2/dist/tweakpane.min.js"></script>
  <script src="js/fstdropdown.js"></script>
  <link rel="stylesheet" href="css/fstdropdown.css">
  <a href="index.html"></a>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style type="text/css">
    #gui {
    position: absolute;
    left: 2px;   /* position inside relatively positioned parent */
    top: 140px;
    z-index: 10;   /* adjust as needed */
    }
    #tp {
    position: absolute;
    left: 2px;   /* position inside relatively positioned parent */
    top: 140px;
    z-index: 10;   /* adjust as needed */
    }

    #logo{
      position: absolute;
      margin-top: 10px;
      z-index:2;
    }
  
    .button {
  border: none;
  color: white;
  padding: 16px 30px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  transition-duration: 0.4s;
  cursor: pointer;
  position: absolute;
  left: 2px;   /* position inside relatively positioned parent */
  top: 360px;
  z-index: 10; 
}

.button1 {
  background-color: rgb(47,49,55); 
  color: rgb(167, 167, 167); 
  border: 0px solid #000000;
}

.button2 {
  border: none;
  padding: 16px 45px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  transition-duration: 0.4s;
  cursor: pointer;
  position: absolute;
  left: 140px;   /* position inside relatively positioned parent */
  top: 360px;
  z-index: 10; 
}

.button3 {
  border: none;
  padding: 16px 30px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  transition-duration: 0.4s;
  cursor: pointer;
  position: absolute;
  left: 2px;   /* position inside relatively positioned parent */
  top: 420px;
  z-index: 10; 
}


.button4 {
  border: none;
  padding: 16px 50px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  transition-duration: 0.4s;
  cursor: pointer;
  position: absolute;
  left: 140px;   /* position inside relatively positioned parent */
  top: 420px;
  z-index: 10; 
}


.button1:hover {
  background-color: #000000;
  color: white;
}

.p1 {
  font-family: Helvetica, sans-serif;
  position: absolute;
  font-size: 14px;
  left: 8px;   /* position inside relatively positioned parent */
  top: 267px;
  z-index: 10; 
}

#openbutton{
  font-family: Helvetica, sans-serif;
  position: absolute;
  font-size: 17px;
  left: 2px;   /* position inside relatively positioned parent */
  top: 120px;
  z-index: 10; 
  cursor:pointer;
}

#guiplace{
  font-size: 55px;
  position: absolute;
  left: 2px;   /* position inside relatively positioned parent */
  top: 150px;
  z-index: 10; 
  width: 270px;
}

body {
  font-family: 'Lato', sans-serif;
}


.overlay {
  height: 100%;
  width: 0;
  position: absolute;
  z-index: 15;
  top: 0;
  left: 0;
  background-color: rgb(0,0,0);
  background-color: rgba(0,0,0, 0.9);
  overflow-x: hidden;
  transition: 0.5s;
}

.overlay-content {
  position: relative;
  top: 25%;
  width: 100%;
  text-align: center;
  margin-top: 30px;
}

.overlay a {
  padding: 8px;
  text-decoration: none;
  font-size: 36px;
  color: #818181;
  display: block;
  transition: 0.3s;
}

.overlay a:hover, .overlay a:focus {
  color: #f1f1f1;
}

.overlay .closebtn {
  position: absolute;
  top: 20px;
  right: 45px;
  font-size: 60px;
}

@media screen and (max-height: 450px) {
  .overlay a {font-size: 20px}
  .overlay .closebtn {
  font-size: 40px;
  top: 15px;
  right: 35px;
  }
}

@font-face {
    font-family: "MyriadPro-Regular";
    src: url("fonts/MYRIADPROREGULAR.woff") format("woff");
    }
  </style>
</head>

<body>
  <div>
    <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" width = "10%" style="top:1%;left:0.3%;position:absolute;z-index: 100;" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 710.3 222.4" xml:space="preserve"> <style type="text/css"> .st0b{fill:#424A60;} .st1b{fill:#DC298D;} .st2b{fill:#7383BF;} .st3b{fill:#969696;} .st4b{fill:#EBBA16;} .st5b{fill:#06ABEB;} .st6b{font-family:'Helvetica-Bold';} .st7b{font-size:84.3397px;} .st8b{letter-spacing:-1;} </style> <g id="Layer_1_00000056390415183483724190000009750584087129516189_"> <g id="path5"> <rect x="92.8" y="154.2" transform="matrix(0.3589 -0.9334 0.9334 0.3589 -62.6169 220.6174)" class="st0b" width="72.9" height="3.3"/> </g> <rect id="path4" x="156.9" y="60.1" transform="matrix(0.8102 -0.5861 0.5861 0.8102 0.7614 131.2305)" class="st0b" width="92.3" height="8.7"/> <g id="path3"> <rect x="19" y="127.2" transform="matrix(0.9138 -0.4063 0.4063 0.9138 -46.9835 44.8278)" class="st0b" width="126.2" height="11.8"/> </g> <g id="path2"> <rect x="122.6" y="16.9" transform="matrix(0.9138 -0.4063 0.4063 0.9138 -9.3065 55.4032)" class="st0b" width="6.4" height="65.4"/> </g> <rect id="path1" x="169" y="110.3" transform="matrix(0.9138 -0.4063 0.4063 0.9138 -48.6296 83.9257)" class="st0b" width="8.7" height="92.3"/> <circle id="circle6" class="st1b" cx="249.7" cy="34.5" r="21.8"/> <circle id="circle5" class="st2b" cx="112.1" cy="200.6" r="21.8"/> <circle id="circle4" class="st1b" cx="21.8" cy="156.5" r="21.8"/> <circle id="circle3" class="st3b" cx="109.6" cy="13.1" r="13.1"/> <circle id="circle2" class="st4b" cx="189.6" cy="193.1" r="13.1"/> <circle id="circle1" class="st5b" cx="149.5" cy="102.8" r="37.3"/> </g> <g id="Layer_2_00000013871697503241264390000008040421359665832584_"> <text transform="matrix(1 -3.490651e-03 3.490651e-03 1 243.0089 140.7256)" class="st6b st7b">PhosNet</text> <text transform="matrix(1 -3.490651e-03 3.490651e-03 1 585.1035 139.5315)" class="st6b st7b st8b">V</text> <text transform="matrix(1 -3.490651e-03 3.490651e-03 1 639.8698 139.3403)" class="st6b st7b">is</text> </g> </svg>
  </div>

  <span id = "openbutton" value=0 onclick="hideShowMenu(this.value)">&times; close</span>

  <p id = "nqText" class="p1">Node Query</p>
  
  <p  id="nodequeryMain">
    <select class='fstdropdown-select' id="nodequery" onchange="updateSearch()">
        <option value="">--</option>
    </select>
</p>


<div id = "screenshotButton">
<svg version="1.1" onclick="screenshot()" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
    viewBox="0 0 114 30" width = "8%" style="left:15px;top:350px;background-color: rgba(255,255,255,0); cursor: pointer;  z-index: 30; position:absolute;" xml:space="preserve"> <style type="text/css"> .st0{font-family:'MyriadPro-Regular';} .st1{font-size:22px;} </style> <g> <path d="M6,19v-2c0-0.6-0.4-1-1-1l0,0c-0.6,0-1,0.4-1,1v2c0,0.6,0.4,1,1,1l0,0C5.6,20,6,19.6,6,19z"/> <path d="M10,5L10,5c0,0.6,0.4,1,1,1h2c0.6,0,1-0.4,1-1l0,0c0-0.6-0.4-1-1-1h-2C10.4,4,10,4.4,10,5z"/> <path d="M5,14L5,14c0.6,0,1-0.4,1-1v-2c0-0.6-0.4-1-1-1l0,0c-0.6,0-1,0.4-1,1v2C4,13.6,4.4,14,5,14z"/> <path d="M23,6h1v1c0,0.6,0.4,1,1,1l0,0c0.6,0,1-0.4,1-1V6c0-1.1-0.9-2-2-2h-1c-0.6,0-1,0.4-1,1l0,0C22,5.6,22.4,6,23,6z"/> <path d="M16,5L16,5c0,0.6,0.4,1,1,1h2c0.6,0,1-0.4,1-1l0,0c0-0.6-0.4-1-1-1h-2C16.4,4,16,4.4,16,5z"/> <path d="M7,24H6v-1c0-0.6-0.4-1-1-1l0,0c-0.6,0-1,0.4-1,1v1c0,1.1,0.9,2,2,2h1c0.6,0,1-0.4,1-1l0,0C8,24.4,7.6,24,7,24z"/> <path d="M6,7V6h1c0.6,0,1-0.4,1-1l0,0c0-0.6-0.4-1-1-1H6C4.9,4,4,4.9,4,6v1c0,0.6,0.4,1,1,1l0,0C5.6,8,6,7.6,6,7z"/> <path d="M24,11v2c0,0.6,0.4,1,1,1l0,0c0.6,0,1-0.4,1-1v-2c0-0.6-0.4-1-1-1l0,0C24.4,10,24,10.4,24,11z"/> </g> <g> <path d="M25,16h-1.8c-0.8,0-1.5-0.4-1.8-1.1l-0.2-0.3c-0.2-0.3-0.5-0.6-0.9-0.6h-4.8c-0.4,0-0.7,0.2-0.9,0.6l-0.2,0.3 c-0.3,0.7-1,1.1-1.8,1.1H11c-0.6,0-1,0.4-1,1v8c0,0.6,0.4,1,1,1h14c0.6,0,1-0.4,1-1v-8C26,16.4,25.6,16,25,16z M18,25 c-2.2,0-4-1.8-4-4s1.8-4,4-4s4,1.8,4,4S20.2,25,18,25z"/> <circle cx="18" cy="21" r="2"/> </g> <text transform="matrix(1 0 0 1 28.4106 22)" class="st0 st1">Snapshot</text>
</svg>  
</div>

<div id = "resetButton">
<svg version="1.1" onclick="queryReset()" id="Layer_2" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 1068.5 512" width = "6.5%" style="left:165px;top:343px;background-color: rgba(255,255,255,0); cursor: pointer;  z-index: 30; position:absolute;" xml:space="preserve"> <style type="text/css"> .st0a{font-family:'MyriadPro-Regular';} .st1a{font-size:239.4106px;} </style> <path d="M218.4,320.6l28.4,28.4H157c-51.4,0-93-41.6-93-93s41.6-93,93-93h18v-30h-18c-67.9,0-123,55.1-123,123s55.1,123,123,123 h89.8l-28.4,28.4l21.2,21.2l64.6-64.6l-64.6-64.6L218.4,320.6z"/> <path d="M355,133h-89.8l28.4-28.4l-21.2-21.2L207.8,148l64.6,64.6l21.2-21.2L265.2,163H355c51.4,0,93,41.6,93,93s-41.6,93-93,93 h-18.6v30H355c67.9,0,123-55.1,123-123S422.9,133,355,133z"/> <text transform="matrix(1 0 0 1 496.8376 327.6711)" class="st0a st1a">Reset</text>
</svg>
</div>
  <!-- <button class="button2" onclick="queryReset()">Reset</button> -->

  <!-- <button class="button3" onclick="animation()">Animation</button>

  <button class="button4" onclick="stopAnimation()">Stop</button> -->

  <div id="guiplace"> </div>

  <div id="3d-graph"></div>

  <div id = "legend" class="dg ac">
    <div class="dg main a" style="position: absolute;"> 
      <img src="./img/Legend_3.png" alt="" style="width: 273px; margin-top: 400px; margin-left: 3px; z-index:2;" >
      
    </div>
  </div>
<script>

// const fragmentShader = `
// uniform vec3 color;
// uniform float coefficient;
// uniform float power;
// varying vec3 vVertexNormal;
// varying vec3 vVertexWorldPosition;
// void main() {
//   vec3 worldCameraToVertex = vVertexWorldPosition - cameraPosition;
//   vec3 viewCameraToVertex	= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;
//   viewCameraToVertex = normalize(viewCameraToVertex);
//   float intensity	= pow(
//     coefficient + dot(vVertexNormal, viewCameraToVertex),
//     power
//   );
//   gl_FragColor = vec4(color, intensity);
// }`;

// const vertexShader = `
// varying vec3 vVertexWorldPosition;
// varying vec3 vVertexNormal;
// void main() {
//   vVertexNormal	= normalize(normalMatrix * normal);
//   vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
//   gl_Position	= projectionMatrix * modelViewMatrix * vec4(position, 1.0);
// }
// `;

// const defaultOptions = {
//   backside: false,
//   coefficient: 0.5,
//   color: 'gold',
//   size: 2,
//   power: .1,
// };

// // Based off: http://stemkoski.blogspot.fr/2013/07/shaders-in-threejs-glow-and-halo.html
// function createGlowMaterial(coefficient, color, power) {
//   return new THREE.ShaderMaterial({
//     depthWrite: false,
//     fragmentShader,
//     transparent: true,
//     uniforms: {
//       coefficient: {
//         value: coefficient,
//       },
//       color: {
//         value: new THREE.Color(color),
//       },
//       power: {
//         value: power,
//       },
//     },
//     vertexShader,
//   });
// }

// function createGlowGeometry(geometry, size) {
//   // Gather vertexNormals from geometry.faces
//   const glowGeometry = geometry.clone();
//   const vertexNormals = new Array(glowGeometry.vertices.length);
//   glowGeometry.faces.forEach((face) => {
//     if (face instanceof THREE.Face3) {
//       vertexNormals[face.a] = face.vertexNormals[0];
//       vertexNormals[face.b] = face.vertexNormals[1];
//       vertexNormals[face.c] = face.vertexNormals[2];
//     } else {
//       console.error('Face needs to be an instance of THREE.Face3.');
//     }
//   });

//   // Modify the vertices according to vertexNormal
//   glowGeometry.vertices.forEach((vertex, i) => {
//     const { x, y, z } = vertexNormals[i];
//     vertex.x += x * size;
//     vertex.y += y * size;
//     vertex.z += z * size;
//   });

//   return glowGeometry;
// }

// function createGlowMesh(geometry, options = defaultOptions) {
//   const { backside, coefficient, color, size, power } = options;

//   const glowGeometry = createGlowGeometry(geometry, size);
//   const glowMaterial = createGlowMaterial(coefficient, color, power);

//   if (backside) {
//     glowMaterial.side = THREE.BackSide;
//   }

//   return new THREE.Mesh(glowGeometry, glowMaterial);
// }


function hideShowMenu(val) {
  if(val==0 || val == undefined){
    document.getElementById("nqText").style.display = "none";
    document.getElementById("nodequeryMain").style.display = "none";
    document.getElementById("screenshotButton").style.display = "none";
    document.getElementById("resetButton").style.display = "none";
    document.getElementById("openbutton").innerHTML =  "&#9776; open";
    document.getElementById("openbutton").value = 1;
    document.getElementById("legend").style.display = "none";
    document.getElementById("guiplace").style.display = "none";
    
  }
  else{
    document.getElementById("nqText").style.display = "block";
    document.getElementById("nodequeryMain").style.display = "block";
    document.getElementById("screenshotButton").style.display = "block";
    document.getElementById("resetButton").style.display = "inline-block";
    document.getElementById("openbutton").innerHTML =  "&times; close";
    document.getElementById("openbutton").value = 0;
    document.getElementById("legend").style.display = "block";
    document.getElementById("guiplace").style.display = "block";
  }
}

//////////////// DATA CREATION ////////////////

function normalization (values, actual_bounds, desired_bounds) {
  var final = []
  for (var i in values){
    final.push(desired_bounds[0] + (values[i] - actual_bounds[0]) * (desired_bounds[1] - desired_bounds[0]) / (actual_bounds[1] - actual_bounds[0]))
  }
  return final
}

function attribute_dict (dataframe, col_name_source_or_target, col_name_attribute_of_interest) {
  var dictionary = {}
  var data_length = dataframe.loc({columns: [col_name_source_or_target]}).size
  var node, attribute;

  for (var i = 0; i < data_length; i++) {
    node = dataframe.loc({rows: [i], columns: [col_name_source_or_target]}).values[0][0]
    if (dataframe.columns.includes(col_name_attribute_of_interest)) 
    {
      var min_val = Math.min.apply(Math, dataframe[col_name_attribute_of_interest].values)
      var max_val = Math.max.apply(Math, dataframe[col_name_attribute_of_interest].values)
      var actual_bounds = [min_val, max_val]
      var desired_bounds = [0,1]

      attribute = dataframe.loc({rows: [i], columns: [col_name_attribute_of_interest]}).values[0][0]
      if (!(min_val == max_val))
      dictionary[node] = normalization([attribute], actual_bounds, desired_bounds)[0]
      else
      dictionary[node] = 1
    }
    else
    {
      dictionary[node] = null
    }
  }
  return dictionary
}

function links_info (dataframe, col_name_source, col_name_target){
  var links = {}
  var data_length = dataframe.loc({columns: [col_name_source]}).size
  var source, target; 

  for (var i = 0; i < data_length; i++){
    source = dataframe.loc({rows: [i], columns: [col_name_source]}).values[0][0]
    target = dataframe.loc({rows: [i], columns: [col_name_target]}).values[0][0]
    if (source in links) {
      var targetList = links[source]
      if (!(targetList.includes(target))) {
        links[source].push(target)
      }
    }
    else {
      var list = []  
      list.push(target)
      links[source] = list
    }
  }
 return links
}

function partitions_dict (dataframe, col_name_target, col_name_partitions, col_name_attribute_of_interest){
  var partitions = {}
  var sites_repetition = {}
  var data_length = dataframe.loc({columns: [col_name_target]}).size
  var target, key_, value; 

  if (dataframe.columns.includes(col_name_partitions))
  {
  for (var i = 0; i < data_length; i++) {
    key_ = dataframe.loc({rows: [i], columns: [col_name_partitions]}).values[0][0]
    value = dataframe.loc({rows: [i], columns: [col_name_attribute_of_interest]}).values[0][0]
    target = dataframe.loc({rows: [i], columns: [col_name_target]}).values[0][0]
    
    if (target in partitions) {
      if (!(sites_repetition[target].includes(key_))){
        partitions[target].push({key_ : value})
        sites_repetition[target].push(key_) 
      }
    } else {
          partitions[target] = [{key_ : value}]
          sites_repetition[target] = [key_]
    }}}
  return partitions
}

function parseCSV(file_name) {
let dict_to_json = {"nodes": [], "links": []}

var userData = JSON.parse(window.localStorage.getItem(file_name));
var userDF = new dfd.DataFrame(userData)
var source_att_1 = attribute_dict(userDF, "SourceID", "SourceNodeColor") // source_attr_1 // -1, 1
var source_att_2 = attribute_dict(userDF, "SourceID", "SourceNodeSize") // source_attr_2 // 0, 1
var target_att_1 = attribute_dict(userDF, "TargetID", "TargetNodeColor") // TargetAttr1 // -1, 1
var target_att_2 = attribute_dict(userDF, "TargetID", "TargetNodeSize") // TargetAttr2 // 0, 1
var edge_att_1 = attribute_dict(userDF, "TargetID", "EdgeColor") // EdgeAttr1 // // -1, 1
var edge_att_2 = attribute_dict(userDF, "TargetID", "EdgeWeight") // EdgeAttr2 // 0, 1
var partitions = partitions_dict(userDF, "TargetID", "PhosphorylationSiteID", "TargetNodeColor") 
var links = links_info(userDF, "SourceID", "TargetID")
  
var source = userDF["SourceID"].unique().values
var target = userDF["TargetID"].unique().values
  

for (var s in source){
  dict_to_json['nodes'].push({'id': source[s], "group": 1, "source_attr_1": source_att_1[source[s]], "source_attr_2": source_att_2[source[s]]})
}

for (var t in target){
  var positionsObj; 
  if (Object.keys(partitions).length === 0 && partitions.constructor === Object)
  {
    positions_or_target1 = [{key_: target_att_1[target[t]]}]
  }
  else
  {
    positions_or_target1 = partitions[target[t]]
  }
  dict_to_json['nodes'].push({'id': target[t], "group": 2, "target_attr_1": positions_or_target1, "target_attr_2": target_att_2[target[t]]})
}

for (var i in links){
  var source_node = i
  var target_nodes = links[i]
  for (var i = 0; i < target_nodes.length; i++) {
    var target_node = target_nodes[i]
    dict_to_json['links'].push({"source": source_node, "target": target_node, "edge_attr_1": edge_att_1[target_node], "edge_attr_2": edge_att_2[target_node]})
  }
}
dict_to_json['ids'] = source.concat(target)
return dict_to_json;
}

//////////////// JSON to DATA OBJECT ////////////////
var file_names = JSON.parse(localStorage.getItem("file_names"));
var finalDataObj = parseCSV(localStorage.getItem(file_names[0]))
var nodesList = finalDataObj["ids"]
console.log(finalDataObj)
// permittedValues = finalDataObj["nodes"].map(el => [el.id,el.group]);
// console.log(finalDataObj["nodes"])
//////////////// GRAPH CREATION ////////////////
var directed = sessionStorage.getItem("directed")
var elem = document.getElementById('3d-graph');
var Graph = ForceGraph3D({rendererConfig:{preserveDrawingBuffer   : true}})
  .backgroundColor("#ffffff")
(elem)
  .graphData(finalDataObj)
  // .nodeLabel(node => (true) 
  //   ? (`<span style="color: purple">${node.id}</span>`)
  //   : (`<span></span>`))
  .nodeThreeObject(node => (node.group == '2')
    ? CreateTarget(node) // SUBSTRATES
    : CreateSource(node))   // KINASES
  .onNodeDragEnd(node => {
    node.fx = node.x;
    node.fy = node.y;
    node.fz = node.z; })
  .linkWidth(link => (link.edge_attr_2 == null)
    ? 0.5
    : (link.edge_attr_2 + 0.1))
  .linkColor(link => (link.edge_attr_1 == null)
    ? "#808080"
    : colors_general(link.edge_attr_1, true, 'cornflowerblue', 'blue', 'midnightblue', 'blueviolet', 'darkviolet'))
    .linkDirectionalArrowLength(directed => (directed)
    ? 5
    : 0)        
  .linkDirectionalArrowRelPos(0.5)
  .linkOpacity(0.5)
  // .onNodeHover(node => elem.style.cursor = node ? 'pointer' : null)
  .onNodeClick(node => {
    // Aim at node from outside it
    const distance = 40;
    const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);
    Graph.cameraPosition(
      { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }, // new position
      node, // lookAt ({ x, y, z })
      3000  // ms transition duration
    );
  });

/// NODE QUERY FUNCTIONS
function removeOptions(selectElement) {
   var i, L = selectElement.options.length - 1;
   for(i = L; i >= 0; i--) {
      selectElement.remove(i);
   }
   selectElement.fstdropdown.rebind()
}
function addOptions(addText, selectElement)
{
    // Create an Option object       
    var opt = document.createElement("option");        

    // Assign text and value to Option object
    opt.text = addText;
    opt.value = addText;

    // Add an Option object to Drop Down List Box
    selectElement.options.add(opt);
}
nodesList = nodesList.sort()
var x = document.getElementById("nodequery");
var nodeindexes = 0
for(nodeindexes = 0; nodeindexes<nodesList.length;nodeindexes++){
  var optext = nodesList[nodeindexes]
  addOptions(optext,x)
}
        
//////////////// XXXXXX ////////////////

// CREATING SOURCE TARGETS AND COLORING
          
function CreateSource(node)
{
  var node_size
  if (node["source_attr_2"] == null){ // SourceNodeSize
    node_size = 1
  }
  else{
    var node_size = node["source_attr_2"] + 0.5
  }
  var mesh = (new THREE.Mesh(
  new THREE.SphereGeometry(node_size*8,25,25),
  new THREE.MeshLambertMaterial({
    transparent: false,
    depthWrite: false,
    opacity: 1 //changed 0.8 to 1 
  })
))

const sprite1 = new SpriteText(node.id);
sprite1.color = 'rgb(0,0,0)';
sprite1.textHeight = 5;
mesh.add(sprite1);

var node_color
  if (node['source_attr_1'] == null){ // SourceNodeColor
    node_color = 0.5
  }
  else{
    var node_color = node['source_attr_1']
  }

mesh.material.color.setHex(colors_general(node_color, false, 'ffffb3', 'yellow', 'orange', '#ee9a00', '#ff8c00'));


return mesh
}

function CountPartitions(data)
{
  var num_sites_dict = {}
  for (var node in data['nodes'])
  {
    if (data['nodes'][node]['group'] == '2')
      {
      num_sites = Object.keys(data['nodes'][node]['target_attr_1']).length
      var id = data['nodes'][node]['id']
      num_sites_dict[id] = num_sites
      }
  }
  return num_sites_dict
}

function CreateTarget(node)
{
  var node_size
  if (node["target_attr_2"] == null){ // TargetNodeSize
    node_size = 1
  }
  else{
    var node_size = node["target_attr_2"] + 0.5
  }

  var num_sites_dict = CountPartitions(finalDataObj)
  if (num_sites_dict[node['id']] > 1) { // partitions
    verticalPartitions = num_sites_dict[node['id']]
  }
  else // no partitions
    verticalPartitions = 1
  
  radialPartitions = 25
  var mesh = new THREE.Mesh(
  new THREE.CylinderGeometry(node_size*8, node_size*8, node_size*8*verticalPartitions, radialPartitions, verticalPartitions),
  new THREE.MeshLambertMaterial({
    transparent: false,
    depthWrite: false,
    opacity: 1,
    wireframe: false,
    emissive: "#181818",
    vertexColors: THREE.FaceColors,
  }));
  //const glowMesh = createGlowMesh(mesh.geometry, defaultOptions);

  if (!(verticalPartitions == 1))
  {
    for (var i = 0; i < radialPartitions*2*(verticalPartitions); i+=(verticalPartitions*2))
    {
          j = 0
          for (var position in node['target_attr_1']) {
            target_attr_1 = Object.values(node['target_attr_1'][position])
            mesh.geometry.faces[i+(j*2)].color.setHex(colors_target(target_attr_1)); 
            mesh.geometry.faces[i+(j*2)+1].color.setHex(colors_target(target_attr_1));
            var x = 0
            for(x = i+(j*2)+2;x<i+(j*2)+27;x++){
              mesh.geometry.faces[x].color.setHex("0x949494");                  
            }
            for(x = i+(j*2)+27;x<i+(j*2)+52;x++){
              mesh.geometry.faces[x].color.setHex("0xcccccc");                  
            }

            j = j + 1
            }
    }
  }
  else
  {
    // TargetNodeColor does not exist 
    if (Object.values(node['target_attr_1'][0])[0] == null)  { 
      target_attr_1 = "null"
    }
    else  { // TargetNodeColor exists  
      target_attr_1 = Object.values(node['target_attr_1'][0])
    }
    var face = 0
    for(face = 0; face<50;face++){
      mesh.geometry.faces[face].color.setHex(colors_target(target_attr_1));
    }
    face = 0
    for(face = 50; face<75;face++){
      mesh.geometry.faces[face].color.setHex("0x949494");
    }
    for(face = 75; face<100;face++){
      mesh.geometry.faces[face].color.setHex("0xcccccc");
    }
    mesh.geometry.faces[55].color.setHex("0xcccccc");   
  }

if(PARAMS.Labels)
{
  const sprite = new SpriteText(node.id);
  sprite.color = 'rgb(0,0,0)';
  sprite.textHeight = 5;
  //sprite.position.y = 15;
  mesh.add(sprite);
}
//mesh.add(glowMesh)
  return mesh
  }

function colors_target (l2fc_value) {
  // https://github.com/anomal/RainbowVis-JS look at example.html for usage
  // https://stackoverflow.com/questions/3080421/javascript-color-gradient

    var threshold_max = PARAMS.MaxFold // 1
    var threshold_min = PARAMS.MinFold // -1
    var rainbow = new Rainbow(); 
    rainbow.setNumberRange(-3, 3);
    rainbow.setSpectrum('2600e6', '2A00FF', '5533FF', '7F66FF', 'AA99FF', 'D4CCFF', 'cccccc', 'FFCCDD', 'FF99BB', 'FF6699', 'FF3377', 'FF0055', 'CC0044')

    if (l2fc_value >= threshold_min && l2fc_value <= threshold_max || l2fc_value=="null") {
      return "0xcccccc"
    }
    if (l2fc_value < threshold_min) {
      var hexColour = rainbow.colourAt(l2fc_value-threshold_min);
      var stringColor = '0x' + hexColour
      return stringColor
    } 
    else {
      var hexColour = rainbow.colourAt(l2fc_value-threshold_max);
      var stringColor = '0x' + hexColour
      return stringColor
    } 
}

function colors_general (l2fc_value, isHexFlag, color1, color2, color3, color4, color5) {
    var rainbow = new Rainbow(); 
    thisColor1 = String(color1)
    thisColor2 = String(color2)
    thisColor3 = String(color3)
    thisColor4 = String(color4)
    thisColor5 = String(color5)
    rainbow.setNumberRange(0, 1);
    rainbow.setSpectrum(thisColor1, thisColor2, thisColor3, thisColor4, thisColor5)
    var hexColour = rainbow.colourAt(l2fc_value);
    var stringColor = '0x' + hexColour
    if (isHexFlag){
      var modcolor =  parseInt(hexColour, 16 )
      return modcolor
    }
    else 
      return stringColor
}

function screenshot(){
var ImageBase64 = Graph.renderer().domElement.toDataURL("image/png");
var a = document.createElement("a"); //Create <a>
a.href = ImageBase64; //Image Base64 Goes here
a.download = "image.png"; //File name Here
a.click(); //Downloaded file
}

const CAMERA_DISTANCE2NODES_FACTOR = 170;

  

const fnames = {};
 for (const key of file_names) {
  fnames[key] = key;
 }

 const PARAMS = {
  States: file_names[0],
  MaxFold : 0,
  MinFold : 0,
  Background : "#ffffff",
  Labels : true
};

const pane = new Tweakpane.Pane({
  container: document.getElementById('guiplace'),
});

pane.addInput(PARAMS, 'States',{options: fnames}).on('change', (ev) => {
  changeState();
  });
pane.addInput(PARAMS, 'MaxFold',{min: 0, max: 3}).on('change', (ev) => {
  updateMaxL2FC();
  });
pane.addInput(PARAMS, 'MinFold',{min: -3, max: 0}).on('change', (ev) => {
  updateMinL2FC();
  });
pane.addInput(PARAMS, 'Background').on('change', (ev) => {
  updateBackground();
  });
pane.addInput(PARAMS, 'Labels').on('change', (ev) => {
  toggleLabels();
  });

//////////////////////////////////////////////
    function updateSearch() {
      var x = document.getElementById("nodequery");
      if(x.value == ""){
        var nodenum = Graph.graphData().nodes.length
        Graph.cameraPosition({x:0,y:0,z:Math.cbrt(nodenum) * CAMERA_DISTANCE2NODES_FACTOR},{x:0,y:0,z:0},2000)
      }

      Graph.nodeThreeObjectExtend(node => {
        var selectedNode = x.value //change
        if (selectedNode == node.id) {
              {   const distance = 100;
                  const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);
                  Graph.cameraPosition(
                      { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }, // new position
                      node, // lookAt ({ x, y, z })
                      3000  // ms transition duration
                      );
              }
          }
      })
    }


    function updateMaxL2FC() {
      threshold_max = PARAMS.MaxFold
      Graph.nodeThreeObject(node => (node.group == '2')
    
          ? CreateTarget(node) // SUBSTRATES
          : CreateSource(node)) // KINASES
        }

    function updateMinL2FC() {
      threshold_min = PARAMS.MinFold
      Graph.nodeThreeObject(node => (node.group == '2')
    
          ? CreateTarget(node) // SUBSTRATES
          : CreateSource(node)) // KINASES
        }
        
    function updateBackground() {
      Graph.backgroundColor(PARAMS.Background)

    }

    function toggleLabels() {
      Graph.nodeThreeObject(node =>  (node.group == '2')
      
          ? CreateTarget(node) // SUBSTRATES
          : CreateSource(node)) // KINASES

    }


    function changeState(){
    var new_file_name = PARAMS.States
    /////////////// JSON FILE ////////////////
    finalDataObj = parseCSV(localStorage.getItem(new_file_name))
    nodesList = finalDataObj["ids"]
       Graph = ForceGraph3D({rendererConfig:{preserveDrawingBuffer: true}})
        .backgroundColor(PARAMS.Background)
      (elem)
        .graphData(finalDataObj)
        .nodeThreeObject(node => (node.group == '2')
          ? CreateTarget(node) // SUBSTRATES
          : CreateSource(node))   // KINASES
        .onNodeDragEnd(node => {
          node.fx = node.x;
          node.fy = node.y;
          node.fz = node.z; })
        .linkWidth(link => (link.edge_attr_2 == null)
          ? 0.5
          : (link.edge_attr_2 + 0.1))
        .linkColor(link => (link.edge_attr_1 == null)
          ? "#808080"
          : colors_general(link.edge_attr_1, true, 'cornflowerblue', 'blue', 'midnightblue', 'blueviolet', 'darkviolet'))
        .linkDirectionalArrowLength(directed => (directed)
          ? 5
          : 0)        
        .linkDirectionalArrowRelPos(0.5)
        .linkOpacity(0.5)
        //.linkAutoColorBy('group')
       // .onNodeHover(node => elem.style.cursor = node ? 'pointer' : null)
        
        .onNodeClick(node => {
          // Aim at node from outside it
          const distance = 40;
          const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);
          Graph.cameraPosition(
            { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }, // new position
            node, // lookAt ({ x, y, z })
            3000  // ms transition duration
          );
          
        });
        var x = document.getElementById("nodequery");
        removeOptions(x)

        var option = document.createElement("option");
        option.text = "--";
        option.value = ""
        x.add(option);
        nodesList = nodesList.sort()
        var nodeindexes = 0
        for(nodeindexes = 0; nodeindexes<nodesList.length;nodeindexes++){
          var optext = nodesList[nodeindexes]
          addOptions(optext,x)
          x.fstdropdown.rebind()
        }
        //////////////////////////////////////////////////////////////////////////
    }


    function queryReset(){
      document.getElementById("nodequery").selectedIndex = 0;
      document.getElementById("nodequery").fstdropdown.rebind()
      var nodenum = Graph.graphData().nodes.length
      Graph.cameraPosition({x:0,y:0,z:Math.cbrt(nodenum) * CAMERA_DISTANCE2NODES_FACTOR},{x:0,y:0,z:0},2000)

    }


































/////////// ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION /////////////////
/////////// ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION /////////////////
/////////// ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION /////////////////
/////////// ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION /////////////////
/////////// ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION /////////////////
/////////// ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION /////////////////
var state;

function attribute_dict_target (dataframe, col_name_source_or_target, col_name_attribute_of_interest) { // Function used for target_att_1 not particions to match the output of the funcion partitions_dict
  var dictionary = {}
  var data_length = dataframe.loc({columns: [col_name_source_or_target]}).size
  var node, attribute;

  for (var i = 0; i < data_length; i++) {
    node = dataframe.loc({rows: [i], columns: [col_name_source_or_target]}).values[0][0]
    if (dataframe.columns.includes(col_name_attribute_of_interest)) 
    {
      var min_val = Math.min.apply(Math, dataframe[col_name_attribute_of_interest].values)
      var max_val = Math.max.apply(Math, dataframe[col_name_attribute_of_interest].values)
      var actual_bounds = [min_val, max_val]
      var desired_bounds = [0,1]

      attribute = dataframe.loc({rows: [i], columns: [col_name_attribute_of_interest]}).values[0][0]
      if (!(min_val == max_val))
      dictionary[node] = [{key_:normalization([attribute], actual_bounds, desired_bounds)[0]}]
      else
      dictionary[node] = 1
    }
    else
    {
      dictionary[node] = null
    }
  }
  return dictionary
}
function source_states (datasets, file_names_str){
  var final = {}
  var ks = new Set(datasets[0]["SourceID"]["data"]) /// Gets the ID's of ONLY the first dataset. For now, all dataset should have the same Source Id's. What varies are the color and size. Ideally, in the future this should be modified to account for datasets containing different ID's
  var ks = [...ks] // transform set into array

  for (var i in datasets){
    var source_att_1 = attribute_dict(datasets[i], "SourceID", "SourceNodeColor")
    var source_att_2 = attribute_dict(datasets[i], "SourceID", "SourceNodeSize")
    for (var k in ks){
      if (datasets[i]["SourceID"]['data'].includes(ks[k])){
        if (ks[k] in final){
          final[ks[k]].push({"dataset": file_names_str[i], "source_attr_1":source_att_1[ks[k]], "source_attr_2": source_att_2[ks[k]]})
        }
        else{
          final[ks[k]] = [{"dataset": file_names_str[i], "source_attr_1":source_att_1[ks[k]], "source_attr_2": source_att_2[ks[k]]}]
        }     
      }
      else{
        if (!(ks[k] in final)){
          final[ks[k]] = []
        }           
      }
    }
  }
  return final
}

function target_states (datasets, file_names_str){
  var final = {}
  var ks = new Set(datasets[0]["TargetID"]["data"]) /// Gets the ID's of ONLY the first dataset. For now, all dataset should have the same Target Id's. What varies are the color and size. Ideally, in the future this should be modified to account for datasets containing different ID's
  var ks = [...ks] // transform set into array

  for (var i in datasets){
    var target_att_2 = attribute_dict(datasets[i], "TargetID", "TargetNodeSize")
    //console.log(target_att_2)
    if (!(datasets[i]["PhosphorylationSiteID"] == null)){
      var target_att_1 = partitions_dict(datasets[i], "TargetID", "PhosphorylationSiteID", "TargetNodeColor")
    }
    else{
      var target_att_1 = attribute_dict_target(datasets[i], "TargetID", "TargetNodeColor")
    }
    //console.log(target_att_1)

    for (var k in ks){
      if (datasets[i]["TargetID"]['data'].includes(ks[k])){
        if (ks[k] in final){
          final[ks[k]].push({"dataset": file_names_str[i], "target_attr_1":target_att_1[ks[k]], "target_attr_2": target_att_2[ks[k]]})
        }
        else{
          final[ks[k]] = [{"dataset": file_names_str[i], "target_attr_1":target_att_1[ks[k]], "target_attr_2": target_att_2[ks[k]]}]
        }     
      }
      else{
        if (!(ks[k] in final)){
          final[ks[k]] = []
        }           
      }
    }
  }
  return final
}

function edge_states (datasets, file_names_str) {
  var final = {}
  var ks = new Set(datasets[0]["TargetID"]["data"])  /// Gets the ID's of ONLY the first dataset. For now, all dataset should have the same Source Id's. What varies are the color and size. Ideally, in the future this should be modified to account for datasets containing different ID's
  var ks = [...ks] // transform set into array

  for (var i in datasets){
    var edge_att_1 = attribute_dict(datasets[i], "TargetID", "EdgeColor")
    var edge_att_2 = attribute_dict(datasets[i], "TargetID", "EdgeWeight")
    for (var k in ks){
      if (datasets[i]["TargetID"]['data'].includes(ks[k])){
        if (ks[k] in final){
          final[ks[k]].push({"dataset": file_names_str[i], "edge_att_1":edge_att_1[ks[k]], "edge_att_2": edge_att_2[ks[k]]})
        }
        else{
          final[ks[k]] = [{"dataset": file_names_str[i], "edge_att_1":edge_att_1[ks[k]], "edge_att_2": edge_att_2[ks[k]]}]
        }     
      }
      else{
        if (!(ks[k] in final)){
          final[ks[k]] = []
        }           
      }
    }
  }
  return final
}

function parseCSV_animation() {
  let dict_to_json = {"nodes": [], "links": []}

  var file_names = JSON.parse(localStorage.getItem("all_files"));
  var file_names_str = JSON.parse(localStorage.getItem("file_names"));

    var length_datasets = file_names_str.length
    var datasets = []
    var init = new dfd.DataFrame(file_names[0]) 
    var source_temp = [init["SourceID"].unique().values] 
    var target_temp = [init["TargetID"].unique().values]
    var source = source_temp[0]
    var target = target_temp[0]
    //console.log(source_temp,target_temp)
    for (var i = 0; i < length_datasets; i++){
      var d = new dfd.DataFrame(file_names[i])
      datasets.push(d)
      source_temp.concat(d["SourceID"].unique().values)
      target_temp.concat(d["TargetID"].unique().values)
      source_compare = [d["SourceID"].unique().values][0]
      target_compare = [d["TargetID"].unique().values][0]
      if(JSON.stringify(source) !== JSON.stringify(source_compare) ||JSON.stringify(target) !== JSON.stringify(target_compare)){
        alert("Files do not have exact same sources and targets, animation cannot be displayed!")
        return false;
      }
    }

    var source_att = source_states(datasets, file_names_str)
    var target_att = target_states(datasets, file_names_str)
    var edge_att = edge_states(datasets, file_names_str)
        
    var links = links_info(new dfd.DataFrame(file_names[0]), "SourceID", "TargetID") /// Gets the links of the first dataset. For now, all dataset should have the same Source-Traget connections. What varies are the color and size. Ideally, in the future this should be modified to account for different ID connections in each dataset or state.
    
    for (var s in source){
      dict_to_json['nodes'].push({'id': source[s], "group": 1, "source_attr": source_att[source[s]]})
    }

    for (var t in target){
      dict_to_json['nodes'].push({'id': target[t], "group": 2, "target_attr": target_att[target[t]]})
    }

    for (var i in links){
      var source_node = i
      var target_nodes = links[i]
      for (var i = 0; i < target_nodes.length; i++) {
        var target_node = target_nodes[i]
        dict_to_json['links'].push({"source": source_node, "target": target_node, "edge_attr": edge_att[target_node]})
      }
    }
    dict_to_json['ids'] = source.concat(target)
    return dict_to_json;
    }

    key_file_name = {}
    for (i in file_names){
      key_file_name[file_names[i]] = parseInt(i)
    }

    var finalDataObjAnimation;

function LinkWidthA(link){
          //var state = settings.States
          var state_idx = key_file_name[state]
          if (link.edge_attr[state_idx]["edge_att_2"] == null){ 
            var link_width = 0.5
          }
          else{
            var link_width = link.edge_attr[state_idx]["edge_att_2"] + 0.1
          }
        return link_width
        }

        function LinkColorA(link){
          //var state = settings.States
          var state_idx = key_file_name[state]
          if (link.edge_attr[state_idx]["edge_att_1"] == null){ 
            var link_color = "#808080"
          }
          else{
            var link_color = colors_general(link.edge_attr[state_idx]["edge_att_1"], true, 'cornflowerblue', 'blue', 'midnightblue', 'blueviolet', 'darkviolet')
          }
        return link_color
        }
        
function CreateSourceA(node)
        {
          var node_size
          var state_idx = key_file_name[state]
          if (node.source_attr[state_idx]["source_attr_2"] == null){ // SourceNodeSize
            node_size = 1
          }
          else{
            var node_size = node.source_attr[state_idx]["source_attr_2"] + 0.5
          }
          var mesh = (new THREE.Mesh(    
          new THREE.SphereGeometry(node_size*8,25,25),
          new THREE.MeshLambertMaterial({
            transparent: false,
            depthWrite: false,
            opacity: 1 //changed 0.8 to 1 
          })
        ))

        const sprite = new SpriteText(node.id);
        sprite.color = 'rgb(0,0,0)';
        sprite.textHeight = 5;
        //sprite.position.y = 15;
        mesh.add(sprite);
        

        var node_color
          if (node.source_attr[state_idx]["source_attr_1"] == null){ // SourceNodeColor
            node_color = 0.5
          }
          else{
            var node_color = node.source_attr[state_idx]["source_attr_1"]
          }

        mesh.material.color.setHex(colors_general(node_color, false, 'ffffb3', 'yellow', 'orange', '#ee9a00', '#ff8c00'));
        return mesh
        }

function CountPartitionsA(data)
        {
          var state_idx = key_file_name[state]
          var num_sites_dict = {}
          for (var node in data['nodes'])
          {
            if (data['nodes'][node]['group'] == '2')
             {
              var id = data['nodes'][node]['id']
              if (data['nodes'][node].target_attr[state_idx]['target_attr_1'] == null) {
                num_sites_dict[id] = 0
              }
              else{
                num_sites = Object.keys(data['nodes'][node].target_attr[state_idx]['target_attr_1']).length
                num_sites_dict[id] = num_sites
              }
             }
          }
          return num_sites_dict
        }

function CreateTargetA(node)
        {
          var node_size
          var state_idx = key_file_name[state]
          if (node.target_attr[state_idx]["target_attr_2"] == null){ // TargetNodeSize
            node_size = 1
          }
          else{
            var node_size = node.target_attr[state_idx]["target_attr_2"] + 0.5
          }

          var num_sites_dict = CountPartitionsA(finalDataObjAnimation)
          if (num_sites_dict[node['id']] > 1) { // partitions
            verticalPartitions = num_sites_dict[node['id']]
          }
          else // no partitions
            verticalPartitions = 1
          
          radialPartitions = 25
          var mesh = new THREE.Mesh(
          new THREE.CylinderGeometry(node_size*8, node_size*8, node_size*8*verticalPartitions, radialPartitions, verticalPartitions),
          new THREE.MeshLambertMaterial({
            transparent: false,
            depthWrite: false,
            opacity: 1,
            wireframe: false,
            emissive: "#181818",
            vertexColors: THREE.FaceColors,
          }));

          if (!(verticalPartitions == 1))
          {
            for (var i = 0; i < radialPartitions*2*(verticalPartitions); i+=(verticalPartitions*2))
            {
                  j = 0
                  for (var position in node.target_attr[state_idx]['target_attr_1']) {
                    target_attr_1 = Object.values(node.target_attr[state_idx]['target_attr_1'][position])
                    mesh.geometry.faces[i+(j*2)].color.setHex(colors_target(target_attr_1)); 
                    mesh.geometry.faces[i+(j*2)+1].color.setHex(colors_target(target_attr_1));
                    var x = 0
                    for(x = i+(j*2)+2;x<i+(j*2)+27;x++){
                      mesh.geometry.faces[x].color.setHex("0x949494");                  
                    }
                    for(x = i+(j*2)+27;x<i+(j*2)+52;x++){
                      mesh.geometry.faces[x].color.setHex("0xcccccc");                  
                    }
  
                    j = j + 1
                    }
            }
          }
          else //no partitions
          {
            //delete outer if else in case of a problem!!!!!
            if (!(node.target_attr[state_idx]['target_attr_1'] == null)){
              if (Object.values(node.target_attr[state_idx]['target_attr_1'][0])[0] == null)  { 
                target_attr_1 = 2
              }
              else  { // TargetNodeColor exists  
                target_attr_1 = Object.values(node.target_attr[state_idx]['target_attr_1'][0])
              }
            }
            else{
              target_attr_1 = 2
            }

            var face = 0
            for(face = 0; face<50;face++){
              mesh.geometry.faces[face].color.setHex(colors_target(target_attr_1));
            }
            face = 0
            for(face = 50; face<75;face++){
              mesh.geometry.faces[face].color.setHex("0x949494");
            }
            for(face = 75; face<100;face++){
              mesh.geometry.faces[face].color.setHex("0xcccccc");
            }

          }

        if(PARAMS.Labels)
        {
          const sprite = new SpriteText(node.id);
          sprite.color = 'rgb(0,0,0)';
          sprite.textHeight = 5;
          mesh.add(sprite);
        }
          return mesh
          }


    /////// MASTER DATA MASTER DATA MASTER DATA MASTER DATA MASTER DATA MASTER DATA MASTER DATA MASTER DATA ////////

var isRotationActive = true ;
var isDrawActive = true ;
var mod = file_names.length
var mynum = 0;
//var myVar;

function timer(){
  isRotationActive = true;
  setTimeout(function(){ isDrawActive = true }, 3000)
}

function drawer(filename){
  isRotationActive = false
      var new_file_name = filename
    /////////////// JSON FILE ////////////////
    finalDataObj = parseCSV(localStorage.getItem(new_file_name))
       Graph = ForceGraph3D({rendererConfig:{preserveDrawingBuffer: true}})
        .backgroundColor(PARAMS.Background)
      (elem)
        .graphData(finalDataObj)
        .nodeThreeObject(node => (node.group == '2')
          ? CreateTarget(node) // SUBSTRATES
          : CreateSource(node))   // KINASES
        .onNodeDragEnd(node => {
          node.fx = node.x;
          node.fy = node.y;
          node.fz = node.z; })
        .linkWidth(link => (link.edge_attr_2 == null)
          ? 0.5
          : (link.edge_attr_2 + 0.1))
        .linkColor(link => (link.edge_attr_1 == null)
          ? "#808080"
          : colors_general(link.edge_attr_1, true, 'cornflowerblue', 'blue', 'midnightblue', 'blueviolet', 'darkviolet'))
        .linkDirectionalArrowLength(directed => (directed)
          ? 5
          : 0)        
        .linkDirectionalArrowRelPos(0.5)
        .linkOpacity(0.5)
        .onNodeHover(node => elem.style.cursor = node ? 'pointer' : null)
        .warmupTicks(200)
        .cooldownTicks(0)
        //.onEngineStop(setTimeout(function(){ isRotationActive = true }, 10000))
        .onEngineStop(timer())
    }

    function changeStateA(statename) {
      state = statename
      Graph.nodeThreeObject(node =>  (node.group == '2')
          ? CreateTargetA(node) // SUBSTRATES
          : CreateSourceA(node)) // KINASES
      Graph.linkWidth(link => LinkWidthA(link))
      Graph.linkColor(link => LinkColorA(link))
      Graph.onEngineStop(timer())
      console.log(file_names[mynum])
      //PARAMS.States = file_names[mynum]
    }

var interval1 = 0
var interval2 = 0
function animation(){
  finalDataObjAnimation = parseCSV_animation()

  if (!finalDataObjAnimation){
    return false;
  }
  state = file_names[mynum]
  Graph = ForceGraph3D()
        .backgroundColor("#ffffff")
      (elem)
        .graphData(finalDataObjAnimation)
        .nodeThreeObject(node => (node.group == '2')
          ? CreateTargetA(node) // SUBSTRATES
          : CreateSourceA(node))   // KINASES
        .linkWidth(link => LinkWidthA(link))
        .linkColor(link => LinkColorA(link))
        .onNodeDragEnd(node => {
          node.fx = node.x;
          node.fy = node.y;
          node.fz = node.z; })
        .linkDirectionalArrowLength(directed => (directed)
          ? 5
          : 0)        
        .linkDirectionalArrowRelPos(0.5)
        .linkOpacity(0.5)

  
  interval1 = setInterval(function() {
    if(isDrawActive){
      isDrawActive = false;
    mynum = (mynum + 1) % mod
    changeStateA(file_names[mynum])
    //drawer(file_names[mynum]);
    //console.log(file_names[mynum])
  }
    }, 100);

    let angle = 0;
    interval2 = setInterval(function() { 
      if (isRotationActive) {
        var nodenum = Graph.graphData().nodes.length
        const distance = Math.cbrt(nodenum) * CAMERA_DISTANCE2NODES_FACTOR
        Graph.cameraPosition({
          x: distance * Math.sin(angle),
          z: distance * Math.cos(angle)
        });
        angle += Math.PI / 300;
      }
    }
    , 10);
/*
    // let angle = 0;
    // setInterval(() => {
      // if (isRotationActive) {
      //   var nodenum = Graph.graphData().nodes.length
      //   const distance = Math.cbrt(nodenum) * CAMERA_DISTANCE2NODES_FACTOR
      //   Graph.cameraPosition({
      //     x: distance * Math.sin(angle),
      //     z: distance * Math.cos(angle)
      //   });
      //   angle += Math.PI / 300;
      // }
    // }, 10);
*/
  }

  function stopAnimation(){
    clearInterval(interval1)
    clearInterval(interval2)
    changeState()
    //PARAMS.States = file_names[mynum]
  }
  /////////// ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION /////////////////
  /////////// ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION /////////////////
  /////////// ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION /////////////////
  /////////// ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION /////////////////
  /////////// ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION /////////////////
  /////////// ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION /////////////////
  /////////// ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION ANIMATION /////////////////

  </script>
</body>